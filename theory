Связь между таблицами.

Внешний ключ - индекс, который ссылается на первичный ключ другой таблицы.

Описание внешних ключей в SQL.
1. "Описание поля" ... REFERENCES table(field);
2. "Описание таблицы", после указания всех полей, ставим "," и пишем:
FOREIGN KEY field REFERENCES table(field) [ON UPDATE {CASCADE|RESTRICT|SET NULL|NON ACTION}]
[ON DELETE {CASCADE|RESTRICT|SET NULL|NON ACTION}];

Виды связей.

1. Один-к-одному;
2. Один-ко-многим;
3. Многие-к-одному;
4. Многие-ко-многим;

Подробнее... 1. Одной записи в первой таблице соответствует одна запись во второй (пример: таблица users и
таблица profiles. Одному пользователю соответствует лишь один профиль). Обеспечивается уникальность.
2. Одной записи в одной таблице соответствует множество записей в другой (пример: таблица users и таблица
закачанных ими файлов, один пользователь может закачивать массу файлов).
3. Соотв. предыдущей, только если наблюдаем связь с точки множества.
4. Связь многие-ко-многим – это связь, при которой множественным записям из одной таблицы (A)
могут соответствовать множественные записи из другой (B).
Связь между поставщиком пива и пивом, которое они поставляют – это связь многие-ко-многим.
Поставщик, во многих случаях, предоставляет более одного вида пива,
а каждый вид пива может быть предоставлен множеством поставщиков.
Связь многие-ко-многим создается с помощью трех таблиц.
Две таблицы – “источника” и одна соединительная таблица.
Первичный ключ соединительной таблицы A_B – составной.
Она состоит из двух полей, двух внешних ключей, которые ссылаются на первичные ключи таблиц A и B.
Все первичные ключи должны быть уникальными.
Это подразумевает и то, что комбинация полей A и B должна быть уникальной в таблице A_B.

Подзапрос.

SELECT * FROM ... WHERE id=(SELECT...), в скобках указан подзапрос
SELECT * FROM `films` WHERE `user_id`=(SELECT `id` FROM `users` WHERE `login`='vasia'); - Сделает нам
выборку фильмов пользователя с именем Вася, учитывая, что в `films` у нас нет пользовательских логинов, а
лишь их id.

Оператор объединения JOIN

CROSS JOIN - устаревший, не желателен в использовании. Пример.
SELECT * FROM `users` CROSS JOIN `films` WHERE users.id=films.user_id.
Почему не рекомендуется к использованию. Сначала происходит объединение таблиц, где каждому полю табл 1
присваивается значение таблицы 2, а потом уже происходит группировка по-критерию, в данном случае по id.
Склеивание 2 таблиц с 1000 записей в каждой, займет много времени и памяти компьютера.

INNER JOIN наиболее часто используемый метод выборки, склеивает лишь те записи, которые имеют соответствия
между собой.
SELECT * FROM `users` INNER JOIN `films` ON users.id=films.user_id WHERE users.login='vasia';
Выведет нам фильмы пользователя Вася соответственно с его id в таблице users и films.

LEFT(RIGHT)JOIN. Возьмем запрос SELECT * FROM `users` JOIN `films` ON users.id=films.user_id
Если у нас будет пользователь, который не имеет еще закачанных фильмов, то соотв этому запросу, мы его не увидим,
т.к. происходит соотв по id в 2-х таблицах. Но при применении LEFT JOIN у нас также будет поле с этим
пользователем, только рядом с фильмами будет <null>. Т.е. в любом случае выберутся все данные из таблицы
слева, и соответствия, если они будут. Соотв. можно проводить подобную операцию и с таблицей "справа",
используется оператор RIGHT JOIN.

Псевдонимы.

Полям в запросе можно давать не только псевдонимы, под которыми мы будем их видеть в резульатной таблице,
а также псевдонимы можно давать таблицам, чтоб потом обращаться к ним, при выборе полей, например:
SELECT u.name, f.name FROM `users` AS u INNER JOIN `films` AS f ON u.id=f.user_id;